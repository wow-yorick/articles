---
title: "计算机程序构造和解释摘抄"
date: 2023-07-06T13:47:41+08:00
lastmod: 2023-07-06T13:47:41+08:00
draft: false
tags: [""]
categories: ["人生"]
author: solid-10

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: false
autoCollapseToc: true
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: '<a href="https://github.com/wow-yorick/articles" rel="noopener" target="_blank">查看源</a>'
reward: false
mathjax: true
---

# 构造过程抽象

心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面
 1. 将若干简单的认识**组合**为一个复合认识，由此产生出各种**复杂的认识**
 2. 将两个认识放在一起**对照**，不管它们如何简单或者复杂，在这样做时并不将它们合二为一。由此得到有关它们的**相互关系**
 3. 将**有关认识**与那些**在实际中**和它们**同在**的所有其他认识**隔离开**，这就是**抽象**，所有具有普遍性的认识都是这样得到的

 人们创建出一些称为程序的规则模式，以指导这类过程的进行。

 LISP具有许多独有的特征，这些特征使它成为**研究重要程序的设计、构造**，以及**各种数据结构**，**并**将其关联与支持它们的语言特征的一种及佳**媒介**

 LISP**最重要的特征**：计算过程的LISP描述本身又可以作为LISP的数据来表示和操作


## 1.1 程序设计的基本元素

### 1.1.1 表达式

描述一个语言时，需要将**注意力特别放在**这一语言所提供的,能够**将简单的认识组合起来形成复杂认识的方法方面**

每种强力语言都为此提供了三种机制

* **基本表达形式** 用于表示语言所关心的最简单的个体
* **组合的方法** 从简单的东西出发构造出复合的元素
* **抽象的方法** 为复合对象命名，并将它们当作单元操作

美观打印格式规则：令各个运算对象垂直对齐

### 1.1.2 命名和环境

需要一种通过名字去使用计算对象的方式:**变量**

实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象

将值与符号关联，而后又能提取出这些值。解释器必须维护某种存储能力，以便保持有关的名字-值的对偶的轨迹，这种存储被称为环境


### 1.1.3 组合式的求值

把与过程性思维有关的各种问题隔离出来

- 要求值一个组合式，做下面的事情
1. 求值该组合式的各个子表达式
2. 将作为最左子表达式(运算符)的值的那个过程运用于相应的实际参数，所谓实际参数也就是其他子表达式(运算对象)的值

环境所扮演的角色就是用于确定表达式中各个符号的意义

对各种表达式的求值规则可以描述为一个简单的通用规则和一组针对不多的特殊形式的专门规则

### 1.1.4 复合过程

- 数和算数运算是基本的数据和过程
- 组合式的嵌套提供了一种组织起多个操作的方法
- 定义是一种受限的抽象手段，它为名字关联相应的值

### 1.1.5 过程应用的代换模型

- 代换的作用只是为了帮助我们领会过程调用中的情况，而不是对解释器实际工作方式的具体描述 （解释器在实际中，一般采用提供形式参数的局部环境的方式，产生"代换"的效果）
- 在模拟工程现象时，我们总是从最简单的不完全的模型开始。随着模型不在能满足更细致检查所考虑的问题，从而必须用进一步精化的模型取代

**运用序和正则序**
- 正则序求值: 完全展开而后归约
- 应用序求值: 先求值参数后应用

采用应用序可以避免对表达式的重复求值，从而提高一些效率，更重要的是，在超出了可以采用替换方式模拟的过程范围后，正则序的处理将变得更复杂的多

### 1.1.6 条件表达式和谓词
用术语*谓词*指哪些返回真假的*过程*，也指那种能求出真或者假的值的*表达式*

`and`和`or`都是**特殊形式** 而**不是**普通的过程，因为他们的子表达式不一定都求值， `not`是一个普通过程

### 1.1.7 实例: 采用牛顿法求平方根
数学函数与程序过程之间的矛盾,是描述一件事*特征*与描述*如何去做*这件事之间的普遍性差异的一个具体反映（明性的知识与行动性的知识之间的差异）

方法： 如果对x的平方根的值有了一个猜测y, 求出y和x/y的平均值（它更接近实际的平方根值）
立方根的近似值: 如果y是x的立方根的一个近似值，更好的一个近似值: x/y^2+2y/3

### 1.1.8 过程作为黑箱抽象

分解为若干子问题，每个过程完成一件可以清除标明的工作，使它们可以被用作定义其他过程的模块

一个过程定义应该能隐藏起一些细节

参数必须是所有过程体里局部的东西

## 1.2 过程与它们所产生的计算

基本算术操作 -> 对其进行组合 -> 定义各种复合过程 -> 对复合过程进行抽象

### 1.2.1 线性的递归和迭代
线性递归过程 (由解释器维持计算的过程)
迭代计算过程（其状态可以用固定数目的状态变量描述的计算过程）
 - 存在着一套固定的规则，一个描述计算过程在从一个状态到下一状态转换时，这些变量的更新方式；
 - 一个可能有的结束检测,描述这一计算过程应该终止的条件

 递归过程：论述的是语法形式上的事实：这个过程的定义中直接或间接地**引用该过程本身**
 递归计算过程：计算过程的进展方式

### 1.2.2 树形递归

树形递归计算过程里所需的步骤数将正比于树中的节点数，其空间需求正比于树的最大深度

在层次结构性的数据上操作，树形递归计算过程是一种自然的、威力强大的工具

例： 换零钱方式统计

### 1.2.3 增长的阶

增长的阶为对数时，当问题规模增大一倍时，所需资源量只增加一个常数

### 1.2.4 求幂

``` scheme
(define (fast-expt b n)
    (expt-iter b n 1))

(define (expt-iter b n a)
    (cond ((= n 0)
            a)
          ((even? n)
            (expt-iter (square b)
                       (/ n 2)
                       a))
          ((odd? n)
            (expt-iter b
                       (- n 1)
                       (* b a)))))
```

定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法

### 1.2.5 最大公约数


```
r = remainder(a/b)
GCD(a,b)=GCD(b,r)
```

### 1.2.6素数检查

1. 寻找因子
如果n不是素数，它必然有一个小于或等于根号nd的因子,意味着只需要在1和根号n之间检查因子

2. 费马检查
多次运行检查，如果测试的次数越多，就可以不断增加对有关结果的信心

3. 概率方法
存在着使出错机会达到任意*小*的检查算法。


## 1.3 用高阶函数做抽象

为公共的模式命名，建立抽象，而后直接在抽象的层次上工作
以过程作为参数，或以过程作为返回值，这类能`操作过程`的过程称为**高阶过程**

### 1.3.1 过程作为参数
### 1.3.2 用lambda构造过程
- let 使人能在尽可能接近其使用的地方建立局部变量约束
- 构成局部变量,不影响外层同名变量
### 1.3.3 过程作为一般性的方法

- 通过区间折半寻找方程的根
- 找出函数的不动点 :: 平均阻尼有助于计算快速收敛

### 1.3.4 过程作为返回值

选择过程的形式要清晰且易理解,使该计算过程中有用的元素能表现为一些相互分离的个体,并使它们还能重新用于其他的应用

`抽象和第一级过程`

高阶过程的重要性，就在于使我们能显式地用程序设计语言的要素去描述这些抽象，使我们能像操作其他计算元素一样去操作它们


# 构造数据抽象

复合数据同样是为了提升我们在设计程序时所位于的`概念层次`,提高设计的模块性，增强语言的表达能力

数据抽象技术能使程序更`容易`设计、维护和修改

复合数据对象能够成为以`混合`与`匹配`

数据导向的程序设计: 允许我们孤立的设计每一种数据表示，然后用添加的方式将它们组合进去(不需要任何修改)

## 2.1 数据抽象导引

过程的使用方式与该过程究竟如何通过更基本的过程实现的具体细节相互分离

`数据抽象的基本思想`,设法构造出一些使用复合数据对象的程序，使它们就像是在*抽象数据*上操作一样
    > 为每一类数据对象标识出一组操作，使得兑这类数据对象的的所有操作都可以基于它们表述，而且在操作这些数据对象时也只能使用它们

我们程序中使用数据的方式应该是这样的，除了完成当前工作所必要的东西之外，它们不对所用数据做任何多余的假设

一种'具体'数据表示的定义，也应该与程序中使用数据的方式无关.

### 2.1.1 实例：有理数的算术运算

### 2.1.2 抽象屏障

把对于具体表示方式的依赖性限制到少数几个界面过程，不但对修改程序有帮助，同时也有助于程序的设计,因为这种做法将使我们能保留考虑不同实现的灵活性
