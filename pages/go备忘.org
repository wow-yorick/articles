* csv read

#+BEGIN_SRC go
    ans := strings.NewReader(string(someData))
	br := csv.NewReader(ans)
	for {
		line, err := br.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Error(err)
			break
		}
		l, c := br.FieldPos(0) //l 为从一开始的行号，c 为从一开始的字节数
		if l == 1 {
			line[0] = strings.TrimPrefix(line[0], "\xEF\xBB\xBF")
		}
     }
#+END_SRC
* 常见并发模式
** 对于从无缓冲channel进行的接收，发生在对该channel进行的发送完成之前
** 对于带缓冲的channel，对于channel的第K个接收完成操作发生在第K+C个发送操作完成之前，其中C是channel的缓存大小
* 读写锁
** 它允许任意读操作同时进行
** 同一时刻，只允许有一个写操作进行
** 并且一个写操作被进行过程中，读操作的进行也是不被允许的
** 读写锁控制下的多个写操作之间都是互斥的
** 写操作与读操作之间也都是互斥的
** 多个读操作之间却不存在互斥关系
** =写解锁= 在进行的时候会试图唤醒所有因欲进行读锁定而被阻塞的Goroutine.
** =读解锁= 在进行的时候只会在已无任何读锁定的情况下试图唤醒一个因欲进行写锁定而被阻塞的Goroutine
** 若对一个未被写锁定的读写锁进行写解锁，会引起一个运行时的恐慌
** 而对一个未被读锁定的读写锁进行读解锁却不会如此